From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RainWarrior <rainwarrior@fry.su>
Date: Thu, 15 Oct 2015 01:00:20 +0300
Subject: [PATCH] using the generic info from InvocationExprent correctly, 1
 more error down


diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index f98c822f58aa151185507a7fd7dc2cb0198f72b8..e6152070d2b155d98fc0b8155db12c12ca3864e0 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -170,65 +170,51 @@ public class InvocationExprent extends Exprent {
     List<StructMethod> matches = getMatchedDescriptors();
     StructMethod desc = null;
     if(matches.size() == 1) desc = matches.get(0);
-    //System.out.println("infer: " + instance + " " + classname + "." + name + " " + getExprType() + " " + upperBound + " " + desc);
 
     VarType type = getExprType();
 
-    List<VarType> toAdd = new ArrayList<VarType>();
-    if(upperBound != null/* && upperBound.type == CodeConstants.TYPE_OBJECT && descriptor.ret.type == CodeConstants.TYPE_OBJECT*/) {
-      genericArgs.clear();
-      //System.out.println("0: " + isStatic + " " + desc + " " + upperBound + " " + descriptor.ret + " " + upperBound.isGeneric());
-      /*if(desc == null) {
-        // more harn than gain
-        // Object -> String
-        if(descriptor.ret.value.equals("java/lang/Object") && !descriptor.ret.equals(upperBound)) {
-          genericArgs.add(upperBound);
-          System.out.println("1: " + upperBound + " " + descriptor.ret);
-        }
-        // List -> List<String>
-        if(upperBound.isGeneric()) {
-          List<VarType> leftArgs = ((GenericType)upperBound).getArguments();
-          //System.out.println("22: " + upperBound + " " + leftArgs.get(0));
-          if(leftArgs.size() == 1 && descriptor.ret.equals(upperBound) && leftArgs.get(0).type == CodeConstants.TYPE_OBJECT) {
-            genericArgs.add(leftArgs.get(0));
-            System.out.println("2: " + upperBound.type + " " + upperBound + " " + leftArgs.get(0).type + " " + leftArgs.get(0));
-          }
-        }
+    genericArgs.clear();
+
+    if(desc != null && desc.getSignature() != null) {
+      VarType ret = desc.getSignature().ret;
+      Map<VarType, VarType> map = new HashMap<VarType, VarType>();
+      // more harm than gain
+      // T -> String
+      /*if(upperBound != null && desc.getSignature().fparameters.size() == 1 && desc.getSignature().fparameters.get(0).equals(ret.value)) {
+        genericArgs.add(upperBound);
       }*/
-      if(desc != null && desc.getSignature() != null) {
-        VarType ret = desc.getSignature().ret;
-        // more harm than gain
-        // T -> String
-        /*if(desc.getSignature().fparameters.size() == 1 && desc.getSignature().fparameters.get(0).equals(ret.value)) {
-          genericArgs.add(upperBound);
-          System.out.println("3: " + upperBound + " " + ret + " " + desc.getSignature().fparameters.get(0));
-        }*/
-        // List<T> -> List<String>
-        if(upperBound.isGeneric() && ret.isGeneric()) {
-          List<VarType> leftArgs = ((GenericType)upperBound).getArguments();
-          List<VarType> rightArgs = ((GenericType)ret).getArguments();
-          List<String> fparams = desc.getSignature().fparameters;
-          if(leftArgs.size() == rightArgs.size() && rightArgs.size() == fparams.size()) {
-            for(int i = 0; i < leftArgs.size(); i++) {
-              VarType l = leftArgs.get(i);
-              VarType r = rightArgs.get(i);
-              if(l != null /*&& l.type == CodeConstants.TYPE_OBJECT && !l.equals(r)*/ && r.value.equals(fparams.get(i))) {
-                genericArgs.add(l);
-                //type = upperBound;
-                System.out.println("4: " + i + " " + l + " " + r + " " + fparams.get(i));
-              }
-              else {
-                genericArgs.clear();
-                break;
-              }
+      // List<T> -> List<String>
+      if(upperBound != null && upperBound.isGeneric() && ret.isGeneric()) {
+        List<VarType> leftArgs = ((GenericType)upperBound).getArguments();
+        List<VarType> rightArgs = ((GenericType)ret).getArguments();
+        List<String> fparams = desc.getSignature().fparameters;
+        if(leftArgs.size() == rightArgs.size() && rightArgs.size() == fparams.size()) {
+          for(int i = 0; i < leftArgs.size(); i++) {
+            VarType l = leftArgs.get(i);
+            VarType r = rightArgs.get(i);
+            if(l != null && r.value.equals(fparams.get(i))) {
+              genericArgs.add(l);
+              map.put(r, l);
+            }
+            else {
+              genericArgs.clear();
+              map.clear();
+              break;
             }
           }
         }
       }
-    }
 
+      if(!map.isEmpty()) {
+        // remap and return generic type
+        VarType newType = ret.remap(map);
+        if(ret != newType) return newType;
+      }
+      return ret;
+    }
     return type;
   }
+
   @Override
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
@@ -405,18 +391,14 @@ public class InvocationExprent extends Exprent {
     StructClass cl = DecompilerContext.getStructContext().getClass(classname);
     Map<VarType, VarType> genArgs = new HashMap<VarType, VarType>();
 
+    // building generic info from the instance
     if(cl != null && cl.getSignature() != null && instance != null && instance.getInferredExprType(null).isGeneric()) {
       GenericType genType = (GenericType)instance.getInferredExprType(null);
       if(genType.getArguments().size() == cl.getSignature().fparameters.size()) {
-        /*System.out.println("remap: " + classname + "." + name + " " + genType);
-        if(instance instanceof FieldExprent) {
-            System.out.println(((FieldExprent)instance).getClassname() + "." + ((FieldExprent)instance).getName());
-        }*/
         for(int i = 0; i < cl.getSignature().fparameters.size(); i++) {
           VarType from = GenericType.parse("T" + cl.getSignature().fparameters.get(i) + ";");
           VarType to = genType.getArguments().get(i);
-          if(from != null && to != null /*&& to.type == CodeConstants.TYPE_OBJECT*/) {
-            //System.out.println("(" + from.type + " " + from + " -> " + to.type + " " + to + ")");
+          if(from != null && to != null) {
             genArgs.put(from, to);
           }
         }
@@ -433,79 +415,30 @@ public class InvocationExprent extends Exprent {
         TextBuffer buff = new TextBuffer();
         boolean ambiguous = setAmbiguousParameters.get(i);
         VarType type = descriptor.params[i];
-        VarType newType = null;
-        if(desc != null && desc.getSignature() != null && /*genericArgs.size() != 0 && */desc.getSignature().params.size() == lstParameters.size()) {
-          newType = desc.getSignature().params.get(i);
-          /*boolean free = false;
-          for(String param : desc.getSignature().fparameters) {
-            if(param.equals(newType.value)) {
-              free = true;
-              break;
-            }
-          }
-
-          if(!free) {*/
-            type = newType;
-          //}
+        // using info from the generic signature
+        if(desc != null && desc.getSignature() != null && desc.getSignature().params.size() == lstParameters.size()) {
+          type = desc.getSignature().params.get(i);
         }
-        //System.out.println("check: " + type + " " + type.remap(genArgs) + " " + type.isGeneric() + " " + type.remap(genArgs).isGeneric());
-        /*if(genArgs.containsKey(type)) {
-          type = genArgs.get(type);
-        }*/
+        // applying generic info from the signature
         VarType remappedType = type.remap(genArgs);
         if(type != remappedType) {
           type = remappedType;
         }
+        // and from the inferred generic arguments
         else if(desc != null && desc.getSignature() != null && genericArgs.size() != 0) {
           Map<VarType, VarType> genMap = new HashMap<VarType, VarType>();
           for(int j = 0; j < genericArgs.size(); j++) {
             VarType from = GenericType.parse("T" + desc.getSignature().fparameters.get(j) + ";");
             VarType to = genericArgs.get(j);
             genMap.put(from, to);
-            //System.out.println("map: (" + from + " -> " + to + ")");
           }
           type = type.remap(genMap);
-          /*if(genMap.containsKey(type)) {
-            type = genMap.get(type);
-          }
-          // this only checks 1 level deep right now
-          else if(type.isGeneric()) {
-            GenericType genType = (GenericType)type;
-            List<VarType> toArgs = new ArrayList<VarType>();
-            boolean changed = false;
-            VarType parent = genType.getParent();
-            if(genMap.containsKey(parent)) {
-              parent = genMap.get(parent);
-              changed = true;
-            }
-            for(VarType arg : genType.getArguments()) {
-              if(genMap.containsKey(arg)) {
-                toArgs.add(genMap.get(arg));
-                changed = true;
-              } else {
-                toArgs.add(arg);
-              }
-            }
-            System.out.println("gen: " + changed + " " + parent + " ");
-            if(changed) {
-              type = new GenericType(type.type, type.arrayDim, type.value, parent, toArgs, genType.getWildcard());
-            }
-          }*/
         }
-        /*if(desc != null && desc.getSignature() != null) {
-          for(String ps: desc.getSignature().fparameters) {
-            VarType param = GenericType.parse("T" + ps + ";");
-            if(param.equals(type)) { // found free argument, need to infer it from the argument
-              type = lstParameters.get(i).getExprType();
-              break;
-            }
-          }
-        }*/
+        // not passing it along if what we get back is more specific
         VarType exprType = lstParameters.get(i).getInferredExprType(type);
-        if(exprType != null /*&& exprType.type != CodeConstants.TYPE_NULL*/ && type != null && type.type == CodeConstants.TYPE_GENVAR) {
+        if(exprType != null && type != null && type.type == CodeConstants.TYPE_GENVAR) {
           type = exprType;
         }
-        //System.out.println("param: " + i + " " + newType + " " + exprType + " " + type + " " + lstParameters.get(i));
         ExprProcessor.getCastedExprent(lstParameters.get(i), type, buff, indent, type.type != CodeConstants.TYPE_NULL, ambiguous, tracer);
         buf.append(buff);
 
@@ -522,7 +455,6 @@ public class InvocationExprent extends Exprent {
     List<StructMethod> matches = new ArrayList<StructMethod>();
 
     StructClass cl = DecompilerContext.getStructContext().getClass(classname);
-    //System.out.println("m: " + classname + "." + name + " " + cl);
     if (cl == null) return matches;
 
     nextMethod:
