From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Lex Manos <LexManos@gmail.com>
Date: Sat, 1 Aug 2015 18:40:43 -0700
Subject: [PATCH] Sort inner class lists, local variables, and variable
 definitions.

This caused inconsistent decompilation, beacuse different JVMs sort HashSets differently.

diff --git a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
index 5a56641c6f614fdf677f8e1900f803f73397867c..b3e9d81eaa3a4d86e4714adf2f8e007af831d670 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
@@ -228,6 +228,7 @@ public class ClassesProcessor {
                 stack.add(nestedClass);
               }
             }
+            Collections.sort(superNode.nested);
           }
         }
       }
@@ -342,7 +343,7 @@ public class ClassesProcessor {
   }
 
 
-  public static class ClassNode {
+  public static class ClassNode implements Comparable<ClassNode> {
 
     public static final int CLASS_ROOT = 0;
     public static final int CLASS_MEMBER = 1;
@@ -441,5 +442,11 @@ public class ClassesProcessor {
       public boolean is_method_reference;
       public boolean is_content_method_static;
     }
+
+    @Override
+    public int compareTo(ClassNode o)
+    {
+        return this.classStruct.qualifiedName.compareTo(o.classStruct.qualifiedName);
+    }
   }
 }
diff --git a/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
index 0704efd84bdbd29cb6c9f5db79337147ac0b2be7..809af6d88b5f7c232539e0dbc4c7c8d7c5e26e3b 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/LambdaProcessor.java
@@ -119,6 +119,7 @@ public class LambdaProcessor {
             }
           }
         }
+        Collections.sort(node.nested);
       }
 
       mt.releaseResources();
@@ -133,6 +134,7 @@ public class LambdaProcessor {
 
           parent_class.nested.add(nd);
           nd.parent = parent_class;
+          Collections.sort(parent_class.nested);
         }
       }
     }
diff --git a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
index 798010e24206ffcfb76b1f4936f9b5d3709a7275..9aedf22af1f60b3e17752769462aee91cd9daeb0 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
@@ -248,6 +248,7 @@ public class NestedClassProcessor {
       if (setEnclosing.contains(node.classStruct.qualifiedName)) {
         node.nested.add(child);
         child.parent = node;
+        Collections.sort(node.nested);
 
         return true;
       }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
index 9296bb3f6007bda9647e2f0d919cdfd311567222..205b1876758155132600148f61f641b64e42369c 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
@@ -833,6 +833,7 @@ public class ExprProcessor implements CodeConstants {
     }
 
     TextBuffer buf = new TextBuffer();
+    lst = Exprent.sortIndexed(lst);
 
     for (Exprent expr : lst) {
       TextBuffer content = expr.toJava(indent, tracer);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
index fbd146eca6b7efc4d56e96121a7c6d91748d077c..5f2cb56a85b9ac61141de1c17b457e5847eb8fff 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
@@ -17,6 +17,8 @@ package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map.Entry;
@@ -140,23 +142,23 @@ public class Exprent implements IMatchable {
       }
     }
   }
-  
+
   // *****************************************************************************
   // IMatchable implementation
   // *****************************************************************************
-  
+
   public IMatchable findObject(MatchNode matchNode, int index) {
-    
+
     if(matchNode.getType() != MatchNode.MATCHNODE_EXPRENT) {
       return null;
     }
 
     List<Exprent> lstAllExprents = getAllExprents();
-    
+
     if(lstAllExprents == null || lstAllExprents.isEmpty()) {
       return null;
     }
-    
+
     String position = (String)matchNode.getRuleValue(MatchProperties.EXPRENT_POSITION);
     if(position != null) {
       if(position.matches("-?\\d+")) {
@@ -170,11 +172,11 @@ public class Exprent implements IMatchable {
   }
 
   public boolean match(MatchNode matchNode, MatchEngine engine) {
-    
+
     if(matchNode.getType() != MatchNode.MATCHNODE_EXPRENT) {
       return false;
     }
-    
+
     for(Entry<MatchProperties, RuleValue> rule : matchNode.getRules().entrySet()) {
       switch(rule.getKey()) {
       case EXPRENT_TYPE:
@@ -188,10 +190,41 @@ public class Exprent implements IMatchable {
         }
         break;
       }
-      
+
     }
-    
+
     return true;
   }
-  
+
+  public static List<Exprent> sortIndexed(List<Exprent> lst) {
+    List<Exprent> ret = new ArrayList<Exprent>();
+    List<VarExprent> defs = new ArrayList<VarExprent>();
+
+    Comparator<VarExprent> comp = new Comparator<VarExprent>() {
+      public int compare(VarExprent o1, VarExprent o2) {
+        return o1.getIndex() - o2.getIndex();
+      }
+    };
+
+    for (Exprent exp : lst) {
+      boolean isDef = exp instanceof VarExprent && ((VarExprent)exp).isDefinition();
+      if (!isDef) {
+        if (defs.size() > 0) {
+          Collections.sort(defs, comp);
+          ret.addAll(defs);
+          defs.clear();
+        }
+        ret.add(exp);
+      }
+      else {
+        defs.add((VarExprent)exp);
+      }
+    }
+
+    if (defs.size() > 0) {
+      Collections.sort(defs, comp);
+      ret.addAll(defs);
+    }
+    return ret;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
index 31f0f86d4423ac537faf31b7f16833f263801b23..4751052a5468ffc469d7166bce648d5b658e040d 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
@@ -235,8 +235,15 @@ public class VarVersionsProcessor {
     Map<Integer, Integer> mapOriginalVarIndices = new HashMap<Integer, Integer>();
 
     // map var-version pairs on new var indexes
-    Set<VarVersionPair> set = new HashSet<VarVersionPair>(mapExprentMinTypes.keySet());
-    for (VarVersionPair pair : set) {
+    List<VarVersionPair> lst = new ArrayList<VarVersionPair>(mapExprentMinTypes.keySet());
+    Collections.sort(lst, new Comparator<VarVersionPair>() {
+      public int compare(VarVersionPair o1, VarVersionPair o2) {
+        if (o1.var != o2.var) return o1.var - o2.var;
+        return o1.version - o2.version;
+      }
+    });
+
+    for (VarVersionPair pair : lst) {
 
       if (pair.version >= 0) {
         int newIndex = pair.version == 1 ? pair.var : counters.getCounterAndIncrement(CounterContainer.VAR_COUNTER);
